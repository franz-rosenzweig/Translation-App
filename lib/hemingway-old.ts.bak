// Utility functions for analyzing text readability and generating Hemingway-style highlights
import { analyzeReadability } from './hemingway';

// Matches sentences ending with period, question mark, or exclamation point followed by space
const sentenceRegex = /[^.!?]+[.!?]\s+/g;

// Matches words (including hyphenated words)
const wordRegex = /\b[\w\-]+\b/g;

// Enhanced word lists for better classification
const weakeningAdverbs = [
  'very', 'really', 'quite', 'rather', 'somewhat', 'definitely', 'certainly', 
  'probably', 'actually', 'basically', 'virtually', 'extremely', 'incredibly',
  'absolutely', 'completely', 'totally', 'utterly', 'entirely', 'perfectly'
];

const fillerWords = [
  'basically', 'actually', 'literally', 'obviously', 'clearly', 'essentially',
  'fundamentally', 'generally', 'typically', 'normally', 'usually', 'simply',
  'just', 'really', 'pretty', 'kind of', 'sort of', 'like'
];

const hedgeWords = [
  'might', 'could', 'perhaps', 'maybe', 'possibly', 'probably', 'seems',
  'appears', 'tends', 'suggests', 'indicates', 'implies', 'presumably',
  'allegedly', 'supposedly', 'apparently'
];

// Enhanced highlight types
export type HighlightType = 
  | 'veryHardSentence'   // 30+ words - Red
  | 'hardSentence'       // 20-29 words - Yellow/Orange  
  | 'weakener'           // Adverbs, fillers, hedges - Blue
  | 'complex'            // Complex words - Purple
  | 'passive'            // Passive voice - Green
  | 'adverb';            // Legacy support

export interface EnhancedHighlight {
  type: HighlightType;
  start: number;
  end: number;
  text: string;
  severity: 'low' | 'medium' | 'high';
  suggestion?: string;
  explanation?: string;
}

export interface EnhancedReadabilityResult {
  grade: number;
  stats: {
    sentences: number;
    words: number;
    syllables: number;
    charactersPerWord: number;
    wordsPerSentence: number;
  };
  highlights: EnhancedHighlight[];
  counts: {
    veryHardSentences: number;
    hardSentences: number;
    weakeners: number;
    complexWords: number;
    passiveVoice: number;
  };
}

// Words that indicate passive voice
const passiveVoiceIndicators = [
  'am',
  'are',
  'is',
  'was',
  'were',
  'be',
  'been',
  'being',
];

export interface ReadabilityResult {
  grade: number;
  stats: {
    sentences: number;
    words: number;
    syllables: number;
    charactersPerWord: number;
    wordsPerSentence: number;
  };
  highlights: Array<{
    type: 'passive' | 'complex' | 'adverb' | 'hardSentence';
    index: number;
    length: number;
    text: string;
    note?: string;
  }>;
}

// Count syllables in a word (simplified algorithm)
function countSyllables(word: string): number {
  word = word.toLowerCase();
  if (word.length <= 3) return 1;
  
  // Remove common endings
  word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
  word = word.replace(/^y/, '');
  
  // Count vowel groups
  const syllables = word.match(/[aeiouy]{1,2}/g);
  return syllables ? syllables.length : 1;
}

// Detects passive voice constructions (simplified)
function findPassiveVoice(text: string) {
  const matches: Array<{ index: number; length: number; text: string }> = [];
  const words = text.split(/\s+/);
  
  for (let i = 0; i < words.length - 1; i++) {
    if (passiveVoiceIndicators.includes(words[i].toLowerCase())) {
      if (words[i + 1].toLowerCase().endsWith('ed') || 
          words[i + 1].toLowerCase().endsWith('en')) {
        const startIndex = text.indexOf(words[i], i === 0 ? 0 : text.indexOf(words[i - 1]));
        matches.push({
          index: startIndex,
          length: words[i].length + 1 + words[i + 1].length,
          text: words[i] + ' ' + words[i + 1]
        });
      }
    }
  }
  
  return matches;
}

// Enhanced analysis functions
export function findEnhancedSentenceDifficulty(text: string): EnhancedHighlight[] {
  const highlights: EnhancedHighlight[] = [];
  const sentences = text.match(/[^.!?]+[.!?]+/g) || [];
  let currentIndex = 0;

  for (const sentence of sentences) {
    const startIndex = text.indexOf(sentence, currentIndex);
    const words = sentence.match(/\b\w+\b/g) || [];
    const wordCount = words.length;

    if (wordCount >= 30) {
      highlights.push({
        type: 'veryHardSentence',
        start: startIndex,
        end: startIndex + sentence.length,
        text: sentence.trim(),
        severity: 'high',
        explanation: `This sentence has ${wordCount} words. Try breaking it into shorter sentences.`,
        suggestion: 'Consider splitting this sentence for better readability.'
      });
    } else if (wordCount >= 20) {
      highlights.push({
        type: 'hardSentence',
        start: startIndex,
        end: startIndex + sentence.length,
        text: sentence.trim(),
        severity: 'medium',
        explanation: `This sentence has ${wordCount} words. Consider shortening it.`,
        suggestion: 'This sentence could be clearer if it were shorter.'
      });
    }

    currentIndex = startIndex + sentence.length;
  }

  return highlights;
}

export function findWeakeners(text: string): EnhancedHighlight[] {
  const highlights: EnhancedHighlight[] = [];
  const allWeakeners = [...weakeningAdverbs, ...fillerWords, ...hedgeWords];
  
  // Create a regex that matches any of the weakening words/phrases
  const weakenerPattern = new RegExp(`\\b(${allWeakeners.join('|')})\\b`, 'gi');
  let match;

  while ((match = weakenerPattern.exec(text)) !== null) {
    const word = match[0].toLowerCase();
    let suggestion = '';
    let explanation = '';

    if (weakeningAdverbs.includes(word)) {
      suggestion = 'Remove this qualifying adverb for stronger writing.';
      explanation = 'Qualifying adverbs often weaken your message.';
    } else if (fillerWords.includes(word)) {
      suggestion = 'Remove this filler word.';
      explanation = 'This word adds no meaning to your sentence.';
    } else if (hedgeWords.includes(word)) {
      suggestion = 'Be more definitive if possible.';
      explanation = 'Hedge words can make writing sound uncertain.';
    }

    highlights.push({
      type: 'weakener',
      start: match.index,
      end: match.index + match[0].length,
      text: match[0],
      severity: 'medium',
      suggestion,
      explanation
    });
  }

  return highlights;
}

export function findEnhancedComplexWords(text: string): EnhancedHighlight[] {
  const highlights: EnhancedHighlight[] = [];
  const wordPattern = /\b[a-zA-Z]{4,}\b/g;
  let match;

  while ((match = wordPattern.exec(text)) !== null) {
    const word = match[0];
    const syllables = countSyllables(word);
    
    // Skip proper nouns (basic check)
    if (word[0] === word[0].toUpperCase() && match.index > 0 && text[match.index - 1] !== '.') {
      continue;
    }

    if (syllables >= 3) {
      highlights.push({
        type: 'complex',
        start: match.index,
        end: match.index + word.length,
        text: word,
        severity: syllables >= 4 ? 'high' : 'medium',
        explanation: `This word has ${syllables} syllables.`,
        suggestion: 'Consider using a simpler alternative.'
      });
    }
  }

  return highlights;
}

export function findEnhancedPassiveVoice(text: string): EnhancedHighlight[] {
  const highlights: EnhancedHighlight[] = [];
  
  // Enhanced passive voice detection
  const passivePatterns = [
    /\b(is|are|was|were|be|been|being)\s+\w*(ed|en)\b/gi,
    /\b(is|are|was|were|be|been|being)\s+(made|given|taken|seen|done|shown|known|written|driven|chosen|spoken|broken|stolen|frozen|eaten|beaten|forgotten|gotten|hidden|ridden|forbidden|bitten|torn|worn|born|sworn|drawn)\b/gi
  ];

  for (const pattern of passivePatterns) {
    let match;
    while ((match = pattern.exec(text)) !== null) {
      highlights.push({
        type: 'passive',
        start: match.index,
        end: match.index + match[0].length,
        text: match[0],
        severity: 'medium',
        explanation: 'This appears to be passive voice.',
        suggestion: 'Consider rewriting in active voice for clarity.'
      });
    }
  }

  return highlights;
}

export function analyzeEnhancedReadability(text: string): EnhancedReadabilityResult {
  if (!text.trim()) {
    return {
      grade: 0,
      stats: { sentences: 0, words: 0, syllables: 0, charactersPerWord: 0, wordsPerSentence: 0 },
      highlights: [],
      counts: { veryHardSentences: 0, hardSentences: 0, weakeners: 0, complexWords: 0, passiveVoice: 0 }
    };
  }

  // Get basic stats from existing function
  const basicResult = analyzeReadability(text);
  
  // Get enhanced highlights
  const sentenceHighlights = findEnhancedSentenceDifficulty(text);
  const weakenerHighlights = findWeakeners(text);
  const complexWordHighlights = findEnhancedComplexWords(text);
  const passiveHighlights = findEnhancedPassiveVoice(text);

  const allHighlights = [
    ...sentenceHighlights,
    ...weakenerHighlights,
    ...complexWordHighlights,
    ...passiveHighlights
  ];

  // Sort by position
  allHighlights.sort((a, b) => a.start - b.start);

  const counts = {
    veryHardSentences: sentenceHighlights.filter(h => h.type === 'veryHardSentence').length,
    hardSentences: sentenceHighlights.filter(h => h.type === 'hardSentence').length,
    weakeners: weakenerHighlights.length,
    complexWords: complexWordHighlights.length,
    passiveVoice: passiveHighlights.length
  };

  return {
    grade: basicResult.grade,
    stats: basicResult.stats,
    highlights: allHighlights,
    counts
  };
}
  // Basic stats
  const sentences = text.match(sentenceRegex) || [];
  const words = text.match(wordRegex) || [];
  const syllableCount = words.reduce((sum, word) => sum + countSyllables(word), 0);
  
  // Calculate Flesch-Kincaid Grade Level
  const wordsPerSentence = words.length / Math.max(sentences.length, 1);
  const syllablesPerWord = syllableCount / Math.max(words.length, 1);
  const gradeLevel = 0.39 * wordsPerSentence + 11.8 * syllablesPerWord - 15.59;
  
  // Find highlights
  const highlights = [
    // Passive voice
    ...findPassiveVoice(text).map(h => ({ ...h, type: 'passive' as const })),
    
    // Complex words (3+ syllables)
    ...words
      .map(word => ({
        word,
        syllables: countSyllables(word),
        index: text.indexOf(word),
      }))
      .filter(({ syllables }) => syllables > 2)
      .map(({ word, index }) => ({
        type: 'complex' as const,
        index,
        length: word.length,
        text: word,
      })),
    
    // Weakening adverbs
    ...words
      .map(word => ({
        word: word.toLowerCase(),
        index: text.indexOf(word),
      }))
      .filter(({ word }) => weakeningAdverbs.includes(word))
      .map(({ word, index }) => ({
        type: 'adverb' as const,
        index,
        length: word.length,
        text: word,
      })),
    
    // Hard to read sentences (more than 25 words)
    ...sentences
      .map(sentence => ({
        sentence,
        wordCount: (sentence.match(wordRegex) || []).length,
        index: text.indexOf(sentence),
      }))
      .filter(({ wordCount }) => wordCount > 25)
      .map(({ sentence, index }) => ({
        type: 'hardSentence' as const,
        index,
        length: sentence.length,
        text: sentence.trim(),
      })),
  ];
  
  return {
    grade: Math.max(0, Math.min(Math.round(gradeLevel), 12)),
    stats: {
      sentences: sentences.length,
      words: words.length,
      syllables: syllableCount,
      charactersPerWord: text.length / Math.max(words.length, 1),
      wordsPerSentence,
    },
    highlights: highlights.sort((a, b) => a.index - b.index),
  };
}
